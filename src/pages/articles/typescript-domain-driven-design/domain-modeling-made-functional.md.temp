---
templateKey: article
title: "Domain Modeling Made Functional Notes"
date: '2019-07-24T10:04:10-05:00'
updated: '2019-08-16T10:04:10-05:00'
description: >-
  In this article, you'll learn how identify the aggregate root and encapsulate a boundary around related entities. You'll also learn how to structure and persist aggregates using the Sequelize ORM on White Label, the open-source Vinyl Trading app. 
tags:
  - DDD
  - TypeScript
  - Software Design
  - Aggregate Root
  - Aggregate
  - Sequelize
category: Domain-Driven Design
image: /img/blog/templates/banners/ddd-blog-banner.png
published: true
anchormessage: This article is part of the upcoming DDD + TypeScript course. <a href="/courses/domain-driven-design-typescript">Check it</a>.
---


- We're often scared of functional programming because of all the mathematical jargon. 

  - Things like monads, monoids, functors, etc- don't really make a lot of sense up front.
    - They CAN be simplified into simpler terms that are easier to conceptually understand, but the point is that it's a new area of study, like anything.
  - Also, think about all the random stuff we were forced to learn in Object-Oriented Programming :p 
    - SOLID, DI, Polymorhpism, etc. There's an equal amount of scary looking things.

- DDD + FP is really good for boring software that we all work on and I  think this is because FP is really good at expressing things to be read by domain experts. 
  - There's a lot less technical jargon. There's types and functions.

- The functional types are really clean and easy to be read by domain experts. Really simple and easy to do a brainstorming session with everyone (technical + non-technical stakeholders) in the same room. 

- Functional domain modeling CAN communicate all design decisions.

- Functional principles
  - Types 
    - They aren't classes
    - They are just names for a set of things
  - Functions
    - They take an input and yield an output
  - Composition
    - All pieces are designed to be connected
    - Composable (Algebraic) Type System, behaviour is separate from the data  
      - This is normally an Anemic system, but in FP, this is actually a good thing
  - AND-ing
    - Fruit Salad = Apple AND Cherry AND Banana
    - This is called a Record Type
  - OR-ing
    - Snack = Apple OR Banana OR Cherry
    - Choice Types
    - Most OO Languages don't have this, but TypeScript does.

Example: Modeling some credit card system with FP.

Normally, when we want to do this in OO, we'll build

```typescript
type CheckNumber = '';
type CardNumber = '';
type CardType = 'VISA' | 'DEBIT';
type CreditCardInfo = '';

type PaymentMethod = 
  Cash |
  CheckNumber |
  CreditCardInfo;

type PaymentAmount = number;
type Currency = 'EUR' | 'USD' | 'CAD';

type Payment = {
  amount: PaymentAmount,
  currency: Currency,
  method: PaymentMethod
}
```

Things that type are good for:
- Type checking to prevent you from passing in a type that's invalid.
- Domain modeling 
  - type Deal = (d: Deck) => (Deck * Card) 
  - This is like having a compile-time unit test. ðŸŽ‰ Really really cool!!!!!
    - We should statically type everything!

# Domain modeling with composable types.

## 1. How to an optional field

We want to use the composable type system to do this.

```typescript
type Nothing = null | '';

type SomeString = string;

type OptionalString = 
  SomeString |
  Nothing;

type SomeNumber = number;

type OptionalNumber = 
  SomeNumber |
  Nothing;

// Nah, we can do better than that. Too much duplicate code.

type Option<T> = T | Nothing;

```

## 2. Simple and constrained values

- Avoid using primitives in objects
- Most strings have some constraint (upper bound)
- Most emails can't be pattern and need to have a value
- Most customer ids need to be positive values

To model these, we create _wrapper_ types.

```typescript
type EmailAddress = string;
type PhoneNumber = string;

type CustomerId = number;
type OrderId = number;
```

- Always prefer to use words from the domain. 
- Now, we can't mix up CustomerId and OrderId.

### Factory methods to protect against invalid

Here's an example of how to validate an email address.

```typescript
let createEmailAddress: EmailAddress | Nothing = (s: string) => s.contains("@") 
  ? s as EmailAddress
  : "" as Nothing;
```

Here's an example of how to validate a 50 character string.

```typescript
type String50 = string;
let createString50: String50 | Nothing = (s: string) => s.length <=50
  ? s as String50
  : "" as Nothing;
```

A constrained type for an int.

```typescript
type OrderLineQty = number;

let createOrderLineQty: Option<OrderLineQty> = (q: number) => q > 0 && q <= 99 
  ? q as OrderLineQty
  : q as Nothing;
```
  

## How do we prevent users from doing bad stuff?

```typescript
type Nothing = null | '';
type EmailAddress = string;

type Option<T> = T | Nothing;

let createEmailAddress: Option<EmailAddress> = (s: string) => s.contains("@") 
  ? s as EmailAddress
  : "" as Nothing;

// I can just do: 

let email: EmailAddress = "diddle.com" // should be invalid but...
```

The object oriented alternative is:

```typescript
interface EmailAddressProps {
  value: string;
}

export class EmailAddress extends ValueObject<EmailAddressProps> {

  get value () : string {
    return this.props.value;
  }

  // Can't invoke with new from outside of class.
  private constructor (props: EmailAddressProps) {
    super(props);
  }

  // Only way to create an EmailAddress is through the static factory method 
  public static create (email: string): Result<EmailAddress> {
    const guardResult = Guard.againstNullOrUndefined(email, 'email');

    if (guardResult.isFailure() || !TextUtils.validateEmail(email)) {
      return Result.fail<EmailAddress>()
    } else {
      return Result.ok<EmailAddress>(new EmailAddress({ value: email }))
    }

  }
}
```